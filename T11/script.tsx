// Assuming you have a build setup that handles ES modules and environment variables
// import { GoogleGenAI } from '@google/genai'; // Use this if bundling
// Or if loading via script tag, GoogleGenAI might be globally available.
// For TypeScript, we need to declare it if it's global:
declare const GoogleGenAI: any; // Use a more specific type from the library if available

// Import types from the library for better type safety when processing responses
// You might need to import these from the installed @google/genai package:
// import { GenerateContentResponse, Part, ToolOutput, CodeExecutionResult } from '@google/genai/types';
// Or if using a global, you might need to manually define interfaces or use 'any'.
// Let's assume the library provides types and we can import them:
interface GenerateContentResponse {
    // Simplified interface based on usage; refer to actual library types
    candidates?: Array<{
        content?: {
            parts?: Part[];
        };
    }>;
    promptFeedback?: any; // Add other properties as needed
}

interface Part {
    text?: string;
    toolOutputs?: ToolOutput[];
    // Add other potential part types like inlineData etc.
}

interface ToolOutput {
    toolCode?: string; // The code sent to the tool
    toolOutput?: string; // The raw output from the tool
    codeExecutionResults?: CodeExecutionResult[]; // Specific to code execution tool
    // Add other tool output properties
}

interface CodeExecutionResult {
    executableCode?: string; // Code snippet generated by the model
    stdout?: string; // Standard output from execution
    stderr?: string; // Standard error from execution
    outcome?: string; // Execution outcome (e.g., success, error)
    // Add other result properties
}

// Marked library is likely global if loaded via script tag
declare const marked: {
    parse: (markdown: string) => Promise<string>; // marked v4+ parse returns Promise
};


// !! SECURITY WARNING !!
// NEVER hardcode or expose your API key directly in client-side code in production.
// USE A BACKEND SERVER to make API calls securely.
// Ensure process.env.API_KEY is correctly replaced by your build process.
const GEMINI_API_KEY: string | undefined = process.env.API_KEY; // Type as string or undefined

// --- DOM Elements ---
// Use type assertions and check for null
const chatWindow = document.getElementById('chat-window') as HTMLDivElement | null;
const userInput = document.getElementById('user-input') as HTMLTextAreaElement | null;
const sendButton = document.getElementById('send-button') as HTMLButtonElement | null;
const loadingIndicator = document.getElementById('loading') as HTMLDivElement | null;

// Check if essential elements exist
if (!chatWindow || !userInput || !sendButton || !loadingIndicator) {
    console.error("Essential DOM elements not found!");
    // Optionally, display an error message or disable functionality
}


// --- Initialize GoogleGenAI (using public endpoint) ---
let ai: GoogleGenAI | undefined; // Type the ai variable

if (!GEMINI_API_KEY) {
    console.error("GEMINI_API_KEY environment variable is not set.");
    if (chatWindow) {
         const initErrorDiv = document.createElement('div');
         initErrorDiv.classList.add('message', 'system-message');
         initErrorDiv.innerHTML = '<p>Error: API key is not set. Please configure GEMINI_API_KEY.</p>';
         chatWindow.appendChild(initErrorDiv);
    }
    // Disable input if AI cannot be initialized
    if (sendButton) sendButton.disabled = true;
    if (userInput) userInput.disabled = true;
} else {
    try {
        // Cast to any if GoogleGenAI constructor doesn't have a specific type for config
        ai = new (GoogleGenAI as any)({vertexai: false, apiKey: GEMINI_API_KEY});
    } catch (error: any) { // Catch any error type
        console.error("Failed to initialize GoogleGenAI:", error);
        if (chatWindow) {
            const initErrorDiv = document.createElement('div');
            initErrorDiv.classList.add('message', 'system-message');
            initErrorDiv.innerHTML = `<p>Error initializing AI: ${error.message || String(error)}</p>`;
            chatWindow.appendChild(initErrorDiv);
        }
        // Disable input if AI cannot be initialized
        if (sendButton) sendButton.disabled = true;
        if (userInput) userInput.disabled = true;
    }
}


// --- Helper Function to Display Messages ---
// This function takes any number of arguments and converts them to strings for display
async function displayMessage(sender: 'user' | 'ai' | 'system', ...args: any[]): Promise<void> {
     if (!chatWindow) {
         console.error("chatWindow element not found. Cannot display message.");
         return;
     }

    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', `${sender}-message`);

    const contents: string[] = args.map(arg => String(arg ?? '')); // Convert all args to strings

    let htmlContent = '';

    if (sender === 'user') {
        // For user messages, just display plain text wrapped in <p>
        htmlContent = `<p>${contents.join(' ')}</p>`;
    } else { // sender === 'ai' or 'system'
        // For AI/system messages, parse the combined string as markdown
        try {
             // marked.parse expects a string
            htmlContent = await marked.parse(contents.join('\n\n')); // Join multiple args with double newline for separation in markdown
        } catch (e: any) { // Catch any error type
             // If markdown parsing fails, display as plain text with an error note
             console.error("Failed to parse markdown:", e, "Content:", contents.join('\n\n'));
             htmlContent = `<p>AI Response (Markdown Error): ${contents.join(' ')}</p>`;
        }
    }

    messageDiv.innerHTML = htmlContent;
    chatWindow.appendChild(messageDiv);

    // Scroll to the bottom of the chat window
    chatWindow.scrollTop = chatWindow.scrollHeight;
}


// --- Function to Call the AI ---
async function getAIResponse(prompt: string): Promise<string> {
    if (!ai) {
        return "Error: AI not initialized.";
    }
    try {
        // Use the imported type for the result if available
        const result: GenerateContentResponse = await (ai as any).models.generateContent({ // Cast ai to any if GoogleGenAI type doesn't match
            model: 'gemini-2.0-flash',
            contents: prompt, // Use the user's prompt
            config: {
                 // Keep tools if you want the model to potentially use them
                tools: [{codeExecution: {}}],
            },
        });

        const response = result.candidates?.[0]?.content?.parts; // Use optional chaining
        if (!response || response.length === 0) {
             if (result.promptFeedback?.blockReason) {
                 return `Response blocked: ${result.promptFeedback.blockReason}`;
             }
            return "AI did not return content parts.";
        }

        let formattedContent = ''; // Build a single string to parse with marked

        for (const part of response) {
            if (part.text) {
                formattedContent += part.text + '\n\n'; // Add text parts
            } else if (part.toolOutputs && part.toolOutputs.length > 0) {
                // Handle tool outputs, specifically code execution results if present
                const toolOutput = part.toolOutputs[0]; // Assuming one tool output per part

                // Add the executed code itself if available
                 if (toolOutput.toolCode) {
                     formattedContent += '```tool_code\n' + toolOutput.toolCode + '\n```\n';
                 }


                if (toolOutput.codeExecutionResults && toolOutput.codeExecutionResults.length > 0) {
                    const codeResult = toolOutput.codeExecutionResults[0];

                    formattedContent += '**Execution Result:**\n';
                    if (codeResult.stdout) {
                        formattedContent += '```text\n' + codeResult.stdout + '\n```\n'; // Use text language for generic output
                    } else if (codeResult.stderr) {
                         formattedContent += '```text\nError:\n' + codeResult.stderr + '\n```\n'; // Use text language
                    } else if (codeResult.outcome) {
                         formattedContent += `Outcome: ${codeResult.outcome}\n\n`;
                    } else {
                        formattedContent += 'No execution output.\n\n';
                    }

                } else if (toolOutput.toolOutput) {
                    // Handle generic tool output if not a code execution result
                    formattedContent += '**Tool Output:**\n';
                    formattedContent += '```text\n' + toolOutput.toolOutput + '\n```\n';
                }
                // Add handling for other potential tool outputs here if needed

            }
             // Handle other potential part types if the API supports them later
        }

        return formattedContent.trim(); // Return the combined markdown string

    } catch (error: any) { // Catch any error type
        console.error("Error generating content:", error);
        // Return a user-friendly error message
        return `Error: ${error.message || String(error)}`; // Ensure error is converted to string
    }
}

// --- Function to Handle User Input and Display ---
async function handleSend(): Promise<void> {
    if (!userInput || !sendButton || !loadingIndicator) return; // Ensure elements are found

    const prompt = userInput.value.trim();
    if (!prompt) return; // Don't send empty prompts

    // Display user message
    displayMessage('user', prompt);

    // Clear input and disable controls
    userInput.value = '';
    sendButton.disabled = true;
    userInput.disabled = true;
    loadingIndicator.classList.remove('hidden'); // Show loading


    // Get AI response
    const aiContent = await getAIResponse(prompt);

    // Display AI response
    await displayMessage('ai', aiContent);

    // Re-enable controls and hide loading
    sendButton.disabled = false;
    userInput.disabled = false;
    loadingIndicator.classList.add('hidden'); // Hide loading
    userInput.focus(); // Put focus back on input field
}

// --- Event Listeners ---
// Wait for the DOM to be fully loaded before adding listeners
document.addEventListener('DOMContentLoaded', () => {
     if (sendButton && userInput) {
        sendButton.addEventListener('click', handleSend);

        // Allow sending message on Enter key (but not Shift+Enter for new line)
        userInput.addEventListener('keypress', (event: KeyboardEvent) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default newline
                handleSend();
            }
        });

        // Initial focus on input
        userInput.focus();
     } else {
         console.error("Input/Send elements not found, cannot attach listeners.");
     }
});


// Initial message from the system
// This will run as soon as the script is parsed (if not delayed by DOMContentLoaded)
// It's better to put this inside DOMContentLoaded as well.
document.addEventListener('DOMContentLoaded', () => {
     displayMessage('system', 'System Ready. Enter your prompt above.');
});